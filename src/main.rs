mod p2p;
mod service;

use libp2p::{
    identity,
    request_response::{Event as RequestResponseEvent, Message as RequestResponseMessage}, // Renamed for clarity
    swarm::SwarmEvent,
    Multiaddr,
};
use p2p::{build_swarm, MyRequest, MyResponse}; // Import MyRequest and MyResponse
use service::TowerService;
use tower::Service; // Import the tower::Service trait
use futures::StreamExt; // Required for swarm.select_next_some()

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    // Generate a cryptographic identity for this peer.
    let local_key = identity::Keypair::generate_ed25519();
    let local_peer_id = local_key.public().to_peer_id();
    println!("Local peer ID: {}", local_peer_id);

    // Build the swarm using our custom configuration from p2p.rs.
    let mut swarm = build_swarm(local_key)
        .await
        .map_err(|e| format!("Failed to build swarm: {}", e))?; // More specific error context

    // Initialize our Tower service from service.rs.
    let mut service = TowerService;

    // Specify the address to listen on.
    // "/ip4/0.0.0.0/tcp/0" means listen on all IPv4 interfaces on a random OS-assigned TCP port.
    let listen_addr: Multiaddr = "/ip4/0.0.0.0/tcp/0".parse()?;
    swarm.listen_on(listen_addr)?;

    println!("Node starting. Listening for incoming connections...");

    // Main event loop.
    loop {
        match swarm.select_next_some().await {
            // Handle events generated by the RequestResponse Behaviour.
            SwarmEvent::Behaviour(RequestResponseEvent::Message { peer, message }) => {
                match message {
                    // We received an incoming request.
                    RequestResponseMessage::Request { request, channel, .. } => {
                        println!("Received request from peer: {}", peer);

                        // Extract the raw data (Vec<u8>) from MyRequest.
                        let MyRequest(request_data) = request;

                        // Poll the service for readiness.
                        let ready = futures::future::poll_fn(|cx| service.poll_ready(cx)).await;

                        match ready {
                            Ok(()) => {
                                // The service is ready, so we can call it.
                                match service.call(request_data).await {
                                    Ok(response_data) => {
                                        let response_to_send = MyResponse(response_data);
                                        match swarm.behaviour_mut().send_response(channel, response_to_send) {
                                            Ok(_) => println!("Sent response to peer: {}", peer),
                                            Err(e) => eprintln!("Error sending response to peer {}: {:?}", peer, e),
                                        }
                                    }
                                    Err(e) => {
                                        eprintln!("Service call failed for request from peer {}: {}", peer, e);
                                    }
                                }
                            }
                            Err(e) => {
                                eprintln!("Service permanently failed: {}", e);
                            }
                        }
                    }
                    // We received a response to a request we previously sent.
                    RequestResponseMessage::Response { request_id, response } => {
                        let MyResponse(response_data) = response;
                        println!(
                            "Received response for request {:?}: {} bytes",
                            request_id,
                            response_data.len()
                        );
                    }
                }
            }
            SwarmEvent::NewListenAddr { address, .. } => {
                println!("Now listening on {}", address);
            }
            SwarmEvent::ConnectionEstablished { peer_id, endpoint, .. } => {
                println!("Connected to peer: {} on {}", peer_id, endpoint.get_remote_address());
            }
            SwarmEvent::ConnectionClosed { peer_id, cause, .. } => {
                println!("Disconnected from peer: {}. Reason: {:?}", peer_id, cause);
            }
            SwarmEvent::IncomingConnectionError { local_addr, send_back_addr, error, connection_id } => {
                 eprintln!("Incoming connection error. Local Addr: {}, Send Back Addr: {}, Error: {}, Connection ID: {}", local_addr, send_back_addr, error, connection_id);
            }
            SwarmEvent::OutgoingConnectionError { peer_id, error, .. } => {
                eprintln!("Outgoing connection error to peer {:?}: {}", peer_id, error);
            }
            other_event => {
                println!("Unhandled swarm event: {:?}", other_event);
            }
        }
    }
}